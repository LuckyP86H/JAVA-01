# 数据库事务模型

ACID是衡量事务的四个特性。

## 原子性 Atomicity

### 定义

原子性是指一个事务是一个不可分割的工作单位，其中的操作要么都做，要么都不做。如果事务中有一个语句执行失败，则已执行的语句也必须回滚，数据库退回到事务之前的状态。

### 实现原理 undo log

> MySQL的日志有很多种，如二进制日志、错误日志、查询日志、慢查询等。
>
> InnoDB存储引擎还提供了两种事务日志：
>
> **重做日志 redo log**
>
> 保证了事务的持久性
>
> **回滚日志 undo log**
>
> 事务原子性和隔离性实现的基础。

实现原子性的关键，是当事务回滚能够撤销所有已经成功执行的SQL语句。

InnoDB实现回滚，靠的是undo log，当事务对数据库进行修改的时候，InnoDB会生成对应的undo log。如果事务执行失败或者调用了rollback导致事务需要回滚，便可以利用undo log中的信息将数据回滚到修改之前的样子。

undo log属于逻辑日志，它记录的是SQL执行相关的信息，当发生回滚的时候，InnoDB会根据undo log的内容做与之前相反的操作。

```
insert-> delete

delete->insert

update->update
```

## 一致性 Consistency

基本概念

一致性是指事务执行结束后，数据库的完整性约束没有被破坏，事务执行的前后都是合法的数据状态。

数据库的完整性约束包括但不限于：

实体完整性(如行的主键存在且唯一)列完整性(如字段的类型、大小、长度要符合要求)外键约束用户自定义完整性(如转账前后，两个账户余额的和应该不变)实现

可以说，一致性是事务追求的最终目标：前面提到的原子性、持久性和隔离性，都是为了保证数据库状态的一致性。此外，除了数据库层面的保障，一致性的实现也需要应用层面进行保障。

实现一致性的措施包括：

保证原子性、持久性和隔离性，如果这些特性无法保证，事务的一致性也无法保证。数据库本身提供保障，例如不允许向整形列插入字符串值、字符串长度不能超过列的限制等。应用层面进行保障，例如如果转账操作只扣除转账者的余额，而没有增加接收者的余额，无论数据库实现的多么完美，也无法保证状态的一致。

## 隔离性 Isolation

### 定义

与原子性、持久性侧重于研究事务本身不同，隔离性研究的是不同事务之间的相互影响。隔离性是指事务内部的操作与其他事务是隔离的，并发执行的各个事务之间不能互相干扰。

严格的隔离性，对应了事务隔离级别中的 Serializable(可串行化)，但实际应用中出于性能方面的考虑很少会使用可串行化。

隔离性追求的是并发情形下事务之间互不干扰。简单起见，我们仅考虑最简单的读操作和写操作(暂时不考虑带锁读等特殊操作)。

那么隔离性的探讨，主要可以分为两个方面：

1. (一个事务)写操作对(另一个事务)写操作的影响：锁机制保证隔离性。
2. (一个事务)写操作对(另一个事务)读操作的影响：MVCC 保证隔离性。

##### 锁机制

首先来看两个事务的写操作之间的相互影响。

隔离性要求同一时刻只能有一个事务对数据进行写操作，InnoDB 通过锁机制来保证这一点。

锁机制的基本原理可以概括为：

事务在修改数据之前，需要先获得相应的锁。获得锁之后，事务便可以修改数据。该事务操作期间，这部分数据是锁定的，其他事务如果需要修改数据，需要等待当前事务提交或回滚后释放锁。

##### 行锁与表锁

按照粒度，锁可以分为表锁、行锁以及其他位于二者之间的锁。

表锁在操作数据时会锁定整张表，并发性能较差;

行锁则只锁定需要操作的数据，并发性能好。

但是由于加锁本身需要消耗资源(获得锁、检查锁、释放锁等都需要消耗资源)，因此在锁定数据较多情况下使用表锁可以节省大量资源。

MySQL 中不同的存储引擎支持的锁是不一样的，例如 MyIsam 只支持表锁，而 InnoDB 同时支持表锁和行锁，且出于性能考虑，绝大多数情况下使用的都是行锁。

##### 共享锁和排他锁

从数据库管理的角度对锁进行划分，可以分为共享锁和排它锁。

###### 共享锁

也叫读锁或 S 锁，共享锁锁定的资源可以被其他用户读取，但不能修改。在进行SELECT的时候，会将对象进行共享锁锁定，当数据读取完毕之后，就会释放共享锁，这样就可以保证数据在读取时不被修改。比如我们想给 product_comment 在表上加共享锁，可以使用下面这行命令：

```sql
LOCK TABLE product_comment READ;
```

当对数据表加上共享锁的时候，该数据表就变成了只读模式，此时我们想要更新 product_comment 表中的数据，比如下面这样：

```sql
UPDATE product_comment SET product_id = 10002 WHERE user_id = 912178;
```

系统会做出如下提示：

```sql
ERROR 1099 (HY000): Table 'product_comment' was locked with a READ lock and can't be updated
```

也就是当共享锁没有释放时，不能对锁住的数据进行修改。

如果我们想要对表上的共享锁进行解锁，可以使用下面这行命令：

```
UNLOCK TABLE;
```

如果我们想要给某一行加上共享锁呢，比如想对 user_id=912178 的数据行加上共享锁，可以像下面这样：

```
SELECT comment_id, product_id, comment_text, user_id FROM product_comment WHERE user_id = 912178 LOCK IN SHARE MODE
```

###### 排它锁

也叫独占锁、写锁或 X 锁。排它锁锁定的数据只允许进行锁定操作的事务使用，其他事务无法对已锁定的数据进行查询或修改。如果我们想给 product_comment 数据表添加排它锁，可以使用下面这行命令：

```
LOCK TABLE product_comment WRITE;
```

这时只有获得排它锁的事务可以对 product_comment 进行查询或修改，其他事务如果想要在 product_comment 表上查询数据，则需要等待。你可以自己开两个 MySQL 客户端来模拟下。这时我们释放掉排它锁，使用这行命令即可。

```
UNLOCK TABLE;
```

同样的，如果我们想要在某个数据行上添加排它锁，比如针对 user_id=912178 的数据行，则写成如下这样：

```
SELECT comment_id, product_id, comment_text, user_id FROM product_comment WHERE user_id = 912178 FOR UPDATE;
```

另外当我们对数据进行更新的时候，也就是INSERT、DELETE或者UPDATE的时候，数据库也会自动使用排它锁，防止其他事务对该数据行进行操作。当我们想要获取某个数据表的排它锁的时候，需要先看下这张数据表有没有上了排它锁。如果这个数据表中的某个数据行被上了行锁，我们就无法获取排它锁。这时需要对数据表中的行逐一排查，检查是否有行锁，如果没有，才可以获取这张数据表的排它锁。这个过程是不是有些麻烦？这里就需要用到意向锁。

###### 意向锁

（Intent Lock），简单来说就是给更大一级别的空间示意里面是否已经上过锁。举个例子，你可以给整个房子设置一个标识，告诉它里面有人，即使你只是获取了房子中某一个房间的锁。这样其他人如果想要获取整个房子的控制权，只需要看这个房子的标识即可，不需要再对房子中的每个房间进行查找。这样是不是很方便？返回数据表的场景，如果我们给某一行数据加上了排它锁，数据库会自动给更大一级的空间，比如数据页或数据表加上意向锁，告诉其他人这个数据页或数据表已经有人上过排它锁了，这样当其他人想要获取数据表排它锁的时候，只需要了解是否有人已经获取了这个数据表的意向排他锁即可。如果事务想要获得数据表中某些记录的共享锁，就需要在数据表上添加意向共享锁。同理，事务想要获得数据表中某些记录的排他锁，就需要在数据表上添加意向排他锁。这时，意向锁会告诉其他事务已经有人锁定了表中的某些记录，不能对整个表进行全表扫描。

## 持久性 Durability

### 定义

持久性是指事务一旦提交，它对数据库的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响。

### 实现原理 redo log

redo log 和 undo log 都属于 InnoDB 的事务日志。

InnoDB 作为 MySQL 的存储引擎，数据是存放在磁盘中的，如果每次读写数据都需要磁盘 IO效率会很低，所以InnoDB 提供了缓存(Buffer Pool)，Buffer Pool 中包含了磁盘中部分数据页的映射，作为访问数据库的缓冲：

1. ​	当从数据库读取数据时，会首先从 Buffer Pool 中读取，如果 Buffer Pool 中没有，则从磁盘读取后放入 Buffer Pool。
2. ​	当向数据库写入数据时，会首先写入 Buffer Pool，Buffer Pool 中修改的数据会定期刷新到磁盘中(这一过程称为刷脏)。

Buffer Pool 的使用大大提高了读写数据的效率，但是也带来了新的问题：如果 MySQL 宕机，而此时 Buffer Pool 中修改的数据还没有刷新到磁盘，就会导致数据的丢失，事务的持久性无法保证。于是，redo log 被引入来解决这个问题：当数据修改时，除了修改 Buffer Pool 中的数据，还会在 redo log 记录这次操作;当事务提交时，会调用 fsync 接口对 redo log 进行刷盘。如果 MySQL 宕机，重启时可以读取 redo log 中的数据，对数据库进行恢复。

redo log 采用的是 WAL(Write-ahead logging，预写式日志)，所有修改先写入日志再更新到 Buffer Pool，保证了数据不会因 MySQL 宕机而丢失，从而满足了持久性要求。

既然 redo log 也需要在事务提交时将日志写入磁盘，为什么它比直接将 Buffer Pool 中修改的数据写入磁盘(即刷脏)要快呢?

主要有以下两方面的原因：

1. 刷脏是随机 IO，因为每次修改的数据位置随机，但写 redo log 是追加操作，属于顺序 IO。
2. 刷脏是以数据页(Page)为单位的，MySQL 默认页大小是 16KB，一个 Page 上一个小修改都要整页写入;而 redo log 中只包含真正需要写入的部分，无效 IO 大大减少。

#### redo log 与 binlog

我们知道，在 MySQL 中还存在 binlog(二进制日志)也可以记录写操作并用于数据的恢复，但二者是有着根本的不同的。

##### 作用不同

1. redo log 是用于 crash recovery 的，保证 MySQL 宕机也不会影响持久性;
2. binlog 是用于 point-in-time recovery 的，保证服务器可以基于时间点恢复数据，此外 binlog 还用于主从复制。

##### 层次不同

1. redo log 是 InnoDB 存储引擎实现的
2. 而 binlog 是 MySQL 的服务器层实现的，同时支持 InnoDB 和其他存储引擎。

##### 内容不同

1. redo log 是物理日志，内容基于磁盘的 Page。
2. binlog 是逻辑日志，内容是一条条 sql。

##### 写入时机不同

1. redo log 的写入时机相对多元。前面曾提到，当事务提交时会调用 fsync 对 redo log 进行刷盘;这是默认情况下的策略，修改 innodb_flush_log_at_trx_commit 参数可以改变该策略，但事务的持久性将无法保证。除了事务提交时，还有其他刷盘时机：如 master thread 每秒刷盘一次 redo log 等，这样的好处是不一定要等到 commit 时刷盘，commit 速度大大加快。
2. binlog 在事务提交时写入。

## 总结

##### 原子性

​	语句要么全执行，要么全不执行，是事务最核心的特性。事务本身就是以原子性来定义的;实现主要基于 undo log。

##### 持久性

​	保证事务提交后不会因为宕机等原因导致数据丢失;实现主要基于 redo log。

##### 隔离性

​	保证事务执行尽可能不受其他事务影响;

​	InnoDB 默认的隔离级别是 RR，RR 的实现主要基于锁机制、数据的隐藏列、undo log 和类 next-key lock 机制。

##### 一致性

​	事务追求的最终目标，一致性的实现既需要数据库层面的保障，也需要应用层面的保障。



> https://www.cnblogs.com/superchong/p/10847966.html