# IO多路复用[原创]

对于IO的这一块内容，理解起来相对困难，以下是自己对于IO多路复用的推演的理解：

## 客户端服务端的交互过程

1、客户端请求服务端，经过TCP三次握手，连接建立成功；

2、内核等待网卡数据到位；

3、内核将缓冲区数据拷贝到用户空间缓冲区；

## BIO  单线程IO处理

传统的网络IO，属于阻塞IO：

1、**服务端B**主线程不断轮询所有客户端的连接请求；

2、如果有**客户端A**请求连接，则服务器主线程阻塞，专心处理和**客户端A**的连接（TCP的3次握手建立连接）；

3、连接建立成功后，**服务端B**主线程阻塞read（）**客户端A**的请求，如果**客户端A**特别矫情迟迟不发送，服务端B则一直等待。

```java
while(true){
	accept(): 
	read();
}
```

**缺点：哪哪都阻塞，连接也阻塞，读数据也阻塞，其他客户端都没办法请求到服务端，就是串行处理，单位时间内的请求变少了，CPU的大部分时间都是闲置，资源被严重被浪费。**



## 伪NIO 创建多线程（线程池）处理



### 改进1：多线程处理read()

既然连接也阻塞，读数据也阻塞，则先优化read()阻塞。

1、**客户端A**和**服务端B**建立连接（accept()过程还是阻塞的）；

2、连接建立成功！此时**服务端B**主线程开启一个**小秘书线程C**专门处理**客户端A**的read()请求，自己去迎接新的客户端连接去了；

3、**小秘书线程C**等待客户端的请求进来，没有请求过来就一直等，一旦有了请求就进行应用处理；

**缺点：建立连接依旧是阻塞的，虽然开启了新的线程处理read()，但是子线程在执行过程中本质依然是阻塞处理，该等待客户端的请求还是等待**。



### 改进2：多线程处理read(),且read()非IO阻塞

 我们想要让**小秘书C**读数据的时候不要傻傻等待客户端的请求，金贵的CPU资源在等待IO阻塞处理的过程中，干等着太浪费。

1、**客户端A**和**服务端B**建立连接（accept()过程还是阻塞的）；

2、连接建立成功！此时**服务端B**主线程开启一个**小秘书线程C**专门处理**客户端A**的read()请求，自己去迎接新的客户端连接去了；

3、**小秘书线程C**不是傻傻IO阻塞等待，而是循环遍历看数据是否已经准备好，如果read()!=-1 则处理数据；

**缺点：多线程和还是优化操作系统read函数遍历方式，都属于伪异步IO的情况，很大的一个问题是，如果大量的客户端请求会造成服务端的线程资源被耗光的危险，而且线程的上下文切换的调度将会造成额外的资源的消耗。**



## **NIO** 单线程遍历文件标识符列表

> linux中，万物皆文件。
>
> 文件描述符不过是标识socket连接的其中一方的int而已。
> 用户思维：我要向对方发信息；
> 代码思维：【对方】是什么？=>确定对方的IP、端口，建立连接。此时不再称呼对方为“对方”，对方即sockfd。发消息=>向sockfd写入数据。
> https://www.zhihu.com/question/288808056



### 改进1： 单线程遍历文件描述符清单

1、**服务端B**和**客户端A**创建连接成功后，将文件描述符放到一个数组list中。

2、开启一个专门的**线程D**不断遍历list，read()!=1则处理IO，此时做到了**一个线程处理了多个客户端的连接**。

**缺点：还是会遍历到read()=-1的情况，属于一次无效的遍历，浪费资源的系统调用。**



### 改进2：select 是操作系统提供的系统调用函数

1、**服务端B**和**客户端A**创建连接成功后，将文件描述符放到一个数组list中。

2、开启一个专门的**线程D**，**线程D**不再自己遍历list，而是调用select系统函数把list发送给内核去遍历，返回标识好那些文件符是可用的，返回。

3、**线程D**收到操作系统老大的返回后，依旧要遍历list，只是可以只处理有效的文件符；

**缺点：只能监听1024个文件描述符**



### 改进3：poll 也是操作系统提供的系统调用函数，取消了1024的限制。

**select和poll的缺点：**

**拷贝开销：每次调用select，都需要把fd集合从用户态拷贝到内核态，当fd很大的时候，开销很大；**

**遍历开销：需要再内核遍历所有的fd，fd很大的时候消耗较大；**

**select描述符数量限制：select支持的fd数量太小，只有1024**



### 改进4：epoll=event poll 事件驱动

1、读写等事件会注册到文件描述符上；

2、文件描述符有增删改的时候，都无需把集合全部传给内核态，只需要告诉内核态需要变化的一部分即可；

3、当有事件发生时，通过事件驱动回调的方式将文件描述符返回给用户，用户也无需遍历整个文件描述符集合；

4、fd集合大小没有限制，支持10W连接；

