# 类概念

## JVM组成

类加载器子系统、Java运行时数据、字节码执行引擎

## 概念梳理

### Class 文件

User.class文件，存在硬盘中的静态文件。

### Class Content

类加载器将.class文件加载到内存中的数据，还未生成对象，和文件的区别就是一个是物理文件，一个是内存数据。

### Class 对象

类加载器基于JVM虚拟机规范解析而成的对象存储在方法区的内存数据；

User.class，存储在方法区（规范，存放List<Class>），也就是元空间（具体实现）

### 对象

User user=new User();

存储在堆中（创建后存储在新生代中），有一个引用指向方法区。

> 为什么10中不同的语言都可以运行在JVM识别十种语言的代码？
>
> 不同的语言语言规范不一样，源文件不一样，编译器根据不同的语言规范编译成字节码，JVM统一识别字节码。

> （鲁班子牙）

## 类的生命周期

### 加载

JVM 需要完成 3 件事：

```
1.通过类的全限定名获取该类的二进制字节流。
2.将二进制字节流所代表的静态结构转化为方法区的运行时数据结构。
3.在内存中创建一个代表该类的 java.lang.Class 对象，作为方法区这个类的各种数据的访问入口。
```

怎样获取类的二进制字节流，JVM 没有限制。除了从编译好的 .class 文件中读取，还有以下几种方式：

```
从 zip 包中读取，如 jar、war 等
从网络中获取
通过动态代理生成代理类的二进制字节流
从数据库中读取
。。。
```

数组类本身不通过类加载器创建，由 JVM 直接创建，再由类加载器创建数组中的元素类。

加载阶段与连接阶段的部分内容交叉进行，但这两个阶段的开始仍然保持先后顺序。

### 验证

确保 Class 文件的字节流中包含的信息符合当前虚拟机的要求，并且不会危害虚拟机自身的安全。

### 准备

为类变量（静态成员变量）分配内存并设置初始值的阶段。这些变量（不包括实例变量）所使用的内存都在方法区中进行分配。

基本类型初始值（JDK8）https://docs.oracle.com/javase/specs/jls/se8/html/jls-4.html#jls-4.12.5

```
对于 byte 类型，默认值为零，即（byte）0。
对于 short 类型，默认值为零，即（short）0。
对于 int 类型，默认值为零，即 0。
对于 long 类型，默认值为零，即 0L。
对于 float 类型，默认值为正零，即 0.0f。
对于 double 类型，默认值为正零，即 0.0d。
对于 char 类型，默认值为空字符，即 '\u0000'。
对于 boolean 类型，默认值为 false。
对于所有引用类型，默认值为 null。
```

存在特殊情况 https://www.jianshu.com/p/520295a63967

### 解析

虚拟机将常量池内的符号引用替换为直接引用。会把该类所引用的其他类全部加载进来（ 引用方式：继承、实现接口、域变量、方法定义、方法中定义的本地变量）

https://www.cnblogs.com/shinubi/articles/6116993.html

符号引用：一个 java 文件会编译成一个class文件。在编译时，java 类并不知道所引用的类的实际地址，因此只能使用符号引用来代替。

直接引用：直接指向目标的指针（指向方法区，Class 对象）、指向相对偏移量（指向堆区，Class 实例对象）或指向能间接定位到目标的句柄。

### 初始化

类加载过程的最后一步，是执行类构造器 <clinit>() 方法的过程。

<init>() 与 <clinit>() 介绍： https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-2.html#jvms-2.9

https://blog.csdn.net/u013309870/article/details/72975536

<init>()：为 Class 类实例构造器，对非静态变量解析初始化，一个类构造器对应个。

<clinit>()：为 Class 类构造器对静态变量，静态代码块进行初始化，通常一个类对应一个，不带参数，且是 void 返回。当一个类没有静态语句块，也没有对类变量的赋值操作，那么编译器可以不为这个类生成 <clinit>() 方法

**加载顺序：**

<clinit>() 方法是由编译器自动收集类中的所有**类变量的赋值动作\**语句\****和**静态块（static {}）中的语句**合并产生的，编译器收集的顺序由语句在源文件中出现的顺序所决定。

静态语句块中只能访问定义在静态语句块之前的变量，定义在它之后的变量，在前面的静态语句块中可以赋值，但不能访问。

```
static {
    i = 0;  // 给后面的变量赋值，可以正常编译通过
    System.out.println(i);  // 使用后面的变量，编译器会提示“非法向前引用”
}
static int i = 1;
```

虚拟机会保证在子类的 <clinit>() 方法执行之前，父类的 <clinit>() 方法已经执行完毕。

由于父类的 <clinit>() 方法先执行，意味着父类中定义的静态语句块要优先于子类的变量赋值操作。

来看一个类属性加载顺序的问题

**关于接口初始化：**

接口中不能使用静态代码块，但接口也需要通过 <clinit>() 方法为接口中定义的静态成员变量显式初始化。

接口与类不同，接口的 <clinit>() 方法不需要先执行父类的 <clinit>() 方法，只有当父接口中定义的变量被使用时，父接口才会初始化。

虚拟机会保证一个类的 <clinit>() 方法在多线程环境中被正确加锁、同步。如果多个线程同时去初始化一个类，那么只会有一个线程去执行这个类的 <clinit>() 方法。

------

**https://docs.oracle.com/javase/specs/jvms/se8/html/jvms-5.html**

**https://github.com/doocs/jvm/blob/master/docs/08-load-class-time.md**

**https://github.com/doocs/jvm/blob/master/docs/09-load-class-process.md**

> 参考引用：https://www.cnblogs.com/jhxxb/p/10900405.html



## Volatile

volatile修饰的对象的内存区域不可以进行指令重排。

内存屏障。

JVM层面的读写屏障规范：

storeStoreBarrier

Volatile 写

storeStoreBarrier



LoadStoreBarrier

Volatile 读

LoadStoreBarrier

## Happens-before

JVM规定重排序的规则，一共8中情况，这八种情况需要加上内存屏障。

as if serial

不管怎么排序，单线程执行结果不会改变。

## Lock

将当前处理器对应的缓存数据刷新到内存，并且让其他的处理器的缓存失效。

## 缓存

cpu  1ns和内存之间有三级缓存。

L1 L2 L3（80ns）

内存中取数据：

## 缓存行

按快读取，程序局部性原理，可以提高效率

从主存读取数据的时候，是按照缓存行(64字节，是一个工业折中值)来进行的。

失效以缓存行为单位进行失效。

MESI：某一行的四种状态。（缓存一致性协议）

1、缓存数据以行为单位

2、整行数据缓存

3、缓存失效以行为单位



